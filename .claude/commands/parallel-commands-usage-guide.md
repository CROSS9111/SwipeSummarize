# 並列コマンド（prep-parallel と execute-parallel）の使い方

execute-parallelコマンドとprep-parallelコマンドは、Claude CodeでGitワークツリーの概念を利用して並列エージェント実行を自動化するために使用されます。これにより、複数のClaude Codeエージェントが、コードベースの異なる部分で、または同じ機能を同時に実装するために、並行して動作することが可能になります。

この方法は、Claude Codeが時にミスを犯すことがあるため、複数のエージェントに同じ機能に取り組ませて最適な実装を選択することで、開発を加速させることができます。

## 並列エージェント実行の全体ワークフロー

このワークフローは、主に以下のステップで構成されます：

### 1. 環境の準備 (prep-parallel コマンド)

**目的**: 並列実行のための環境（フィーチャーブランチとGitワークツリー）を設定します。

**コマンド形式**:
```bash
/prep-parallel <フィーチャー名> <並列ワークツリーの数>
```

**引数**:
- `<フィーチャー名>`: 実装したい新機能の名前を指定します
- `<並列ワークツリーの数>`: 同時に動作させたいClaude Codeエージェント（ワークツリー）の数を指定します

**動作**:
- このコマンドは、指定された数の新しいGitブランチとGitワークツリーを作成します
- コードベースはそれぞれのワークツリーに複製され、メインのコードベースとは隔離された環境が提供されます
- これにより、Claude Codeエージェントが互いに干渉することなく、独立して作業できるようになります
- コマンドの実行後には、`git worktree list`を使ってすべてが適切に設定されていることを確認できます

**例**:
```bash
/prep-parallel CLI-UI-updates 3
```
"CLI UI updates"という機能のために3つの並列ワークツリーを準備します。

### 2. 計画の作成

実装したい新機能の詳細を記述した**計画MD (plan.md)**ファイルを作成します。

- これは、PRP (Product Requirement Prompt) フレームワークにおける「初期MD (Initial MD)」と同様の役割を果たします
- Claude Codeエージェントが何を構築すべきかの詳細なコンテキストを提供します
- デモンストレーション目的であれば、「BraveエージェントCLIにプライマリーテーマとして赤とオレンジの色を持たせる」といった簡単な記述でも構いません
- ただし、通常はかなり詳細に記述することが推奨されます

### 3. 会話履歴のクリア

execute-parallelを実行する前に、現在のClaude Codeセッションの会話履歴をクリアすることが推奨されます。これにより、新しいコンテキストで作業を開始できます。

```bash
/clear
```

### 4. コマンドの実行 (execute-parallel コマンド)

**目的**: 事前に準備された環境で並列エージェントを実行し、実際のコードを生成します。

**コマンド形式**:
```bash
/execute-parallel <フィーチャー名> <計画MDへのパス> <並列ワークツリーの数>
```

**引数**:
- `<フィーチャー名>`: prep-parallelで指定したものと同じフィーチャー名を指定します
- `<計画MDへのパス>`: 作成した計画MDファイルへのパスを指定します（例: plan.md）
- `<並列ワークツリーの数>`: prep-parallelで指定したものと同じ数を指定します

**動作**:
- Claude Codeは最初に計画MDを読み込みます
- その内容を複数のClaude Codeサブエージェントにディスパッチし、これらのエージェントが同時に同じ機能を実装します
- 各サブエージェントは隔離された環境（ワークツリー）で独自の速度で実行されます
- それぞれが最終的な変更を包括的なresults.mdに報告するよう指示されます
- これらのエージェントは、Serena（コード構造の理解）やArchon（RAG検索）のようなMCPサーバーも活用して、多くの処理を内部的に実行します

**例**:
```bash
/execute-parallel CLI-UI-updates plan.md 3
```

### 5. 結果の評価とマージ

**結果の確認**:
- すべてのエージェントが完了すると、プライマリエージェントは、各サブエージェントがワークツリーで行ったことの要約を提供します
- 開発者は、各ワークツリーに入って実装内容を確認し、テストし、最も良い実装を選択することができます

**実装の選択とマージ**:
```bash
# 結果をレビュー
cat trees/<フィーチャー名>-*/RESULTS.md

# 各実装をテスト
cd trees/<フィーチャー名>-1 && npm test
cd trees/<フィーチャー名>-2 && npm test
cd trees/<フィーチャー名>-3 && npm test

# 最良の実装を選択してメインブランチにマージ
git checkout main
git merge <選択されたブランチ名>
git push origin main
```

## 完全な使用例

```bash
# ステップ 1: 並列環境の準備
/prep-parallel user-authentication 3

# ステップ 2: 計画ファイルの作成（手動）
# plan.md を作成し、ユーザー認証機能の詳細を記述

# ステップ 3: 会話履歴のクリア
/clear

# ステップ 4: 並列実行
/execute-parallel user-authentication plan.md 3

# ステップ 5: 結果の評価（手動）
# 各ワークツリーの実装を確認し、テストし、最良のものを選択

# ステップ 6: 選択した実装をマージ（手動）
git checkout main
git merge feature/user-authentication-2  # 例: 2番目の実装が最良だった場合
```

## 利点

- **品質向上**: 複数のアプローチを比較して最良の実装を選択
- **リスク軽減**: 単一の実装に依存しない
- **並列処理**: 複数のエージェントが同時に作業することで時間短縮
- **隔離された環境**: 各エージェントが独立して作業し、競合を回避

## PRPフレームワークとの組み合わせ

この並列実行プロセスは、PRPフレームワークと組み合わせることで、さらに強力な開発ワークフローを構築することも可能です：

1. 初期MDを作成
2. `/generate-prp` でPRPを生成
3. `/prep-parallel` で並列環境を準備
4. 各ワークツリーで `/execute-prp` を実行
5. 最良の実装を選択してマージ

このアプローチにより、包括的なコンテキストエンジニアリングと並列実行の両方の利点を活用できます。